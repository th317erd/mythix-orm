# TypeScript

Mythix ORM is fully typed and ready for TypeScript.

However, there are some important things to know when using TypeScript with Mythix ORM:

  1. Mythix ORM was written in vanilla JavaScript, and it will stay that way. I personally prefer to work in vanilla JavaScript, and have no plans to convert the entire code base to TypeScript. I am however happy to continue to support the TypeScript community as well as I am able to with my limited knowledge of TypeScript.
  2. I am not master guru of TypeScript. If you find something incorrect, or that could be better written in the TypeScript definition files, then please submit a PR, and I will be happy to merge it and release a new version.
  3. Some things are a little funky until the TypeScript authors fix the issue with `this` in static methods: [issue #5863](https://github.com/microsoft/TypeScript/issues/5863).
  4. Mythix ORM was designed to heavily rely on `connection.getModel` and `connection.getModels`, however these methods are quite difficult to use with TypeScript. It is recommended that you overload these methods in your own classes to provide the correct model types for your application. You can also instead just import your models, and use them directly, and skip using these methods, and all related "models" scopes (i.e. as found on the `Types.Model` and `Types.Models` field types). However, it is very important to note that if you stop using `connection.getModel` and `connection.getModels` and instead rely on imports then you **absolutely must bind your models to a connection**. This could be a problem if you need more than one connection, and it can be a very big problem during unit testing, where it is common for more than one connection to be used in parallel during testing. Run your unit tests serially, or get creative and share one connection across all tests. Always call `this.getModels` inside your unit tests to get your application models, and this will at least help a little (more may still cause you trouble if you are using a bound model inside your tests, but a non-bound model inside your application code). *Any creative solutions to these problems from someone who is better at TypeScript than me would be extremely welcome!*
